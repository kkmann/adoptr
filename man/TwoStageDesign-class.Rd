% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TwoStageDesign.R
\docType{class}
\name{TwoStageDesign-class}
\alias{TwoStageDesign-class}
\alias{TwoStageDesign}
\alias{TwoStageDesign,numeric-method}
\alias{tunable_parameters}
\alias{tunable_parameters,TwoStageDesign-method}
\alias{make_tunable}
\alias{make_tunable,TwoStageDesign-method}
\alias{make_fixed}
\alias{make_fixed,TwoStageDesign-method}
\alias{update,TwoStageDesign-method}
\alias{n1}
\alias{n1,TwoStageDesign-method}
\alias{n2}
\alias{n2,TwoStageDesign,numeric-method}
\alias{n}
\alias{n,TwoStageDesign,numeric-method}
\alias{c2}
\alias{c2,TwoStageDesign,numeric-method}
\alias{scaled_integration_pivots}
\alias{scaled_integration_pivots,TwoStageDesign-method}
\alias{plot,TwoStageDesign-method}
\alias{simulate,TwoStageDesign,numeric-method}
\title{Two-stage designs}
\usage{
TwoStageDesign(...)

\S4method{TwoStageDesign}{numeric}(n1, c1f, c1e, n2_pivots, c2_pivots,
  order = NULL, ...)

tunable_parameters(x, ...)

\S4method{tunable_parameters}{TwoStageDesign}(x, ...)

make_tunable(x, ...)

\S4method{make_tunable}{TwoStageDesign}(x, ...)

make_fixed(x, ...)

\S4method{make_fixed}{TwoStageDesign}(x, ...)

\S4method{update}{TwoStageDesign}(object, params, ...)

n1(d, ...)

\S4method{n1}{TwoStageDesign}(d, round = TRUE, ...)

n2(d, x1, ...)

\S4method{n2}{TwoStageDesign,numeric}(d, x1, round = TRUE, ...)

n(d, x1, ...)

\S4method{n}{TwoStageDesign,numeric}(d, x1, round = TRUE, ...)

c2(d, x1, ...)

\S4method{c2}{TwoStageDesign,numeric}(d, x1, ...)

scaled_integration_pivots(d, ...)

\S4method{scaled_integration_pivots}{TwoStageDesign}(d, ...)

\S4method{plot}{TwoStageDesign}(x, y = NULL, rounded = TRUE, ...,
  k = 100)

\S4method{simulate}{TwoStageDesign,numeric}(object, nsim, dist, theta,
  seed = NULL, ...)
}
\arguments{
\item{...}{optional arguments depending on implementation}

\item{n1}{cf. slot}

\item{c1f}{cf. slot}

\item{c1e}{cf. slot}

\item{n2_pivots}{cf. slot}

\item{c2_pivots}{cf. slot}

\item{order}{order (i.e. number of pivot points in the interior of [c1f, c1e])
of the Gaussian quadrature rule to use for integration}

\item{x}{design}

\item{object}{object to update}

\item{params}{vector of design parameters (must be in same order as returned
by \code{as.numeric(design)})}

\item{d}{design object}

\item{round}{logical, should integer sample size or real sample size be
returned?}

\item{x1}{stage-one outcome}

\item{y}{not used}

\item{rounded}{should n-values be rounded?}

\item{k}{number of points to use for plotting}

\item{nsim}{number of simulation runs}

\item{dist}{data distribution}

\item{theta}{location parameter of the data distribution}

\item{seed}{random seed}
}
\value{
an object of class \code{TwoStageDesign}
}
\description{
\code{TwoStageDesign} is the fundamental design class of this package.
It consits of three first-stage parameters, two-stage two vectors
and additional parameters for implementation.

The argument \code{order} defines the order of the Gaussian quadrature rule.
If it is missing, the length of \code{n2_pivots} is used.

This function allows to plot the stage-two sample size and decision boundary
functions of a \code{TwoStageDesign} and
user-defined elements of the class \code{ConditionalScore}.
}
\details{
\code{n1} denotes the sample size of the first stage.
\code{c1f} and \code{c1e} define decision boundary.
If the first-stage test statistic \code{Z_1} is larger than \code{c1e},
than the trial is stopped early for efficacy and the null hypothesis is
rejected.
If \code{Z_1} is smaller than \code{c1f}, than the null hypothesis is
accpected and the trial is stopped early for futility.
Otherwise, the trial enters in the second stage. In this case,
the stage-two sample size function \code{n2(Z_1)} and the stage-two
rejection boundary \code{c2(Z_1)} are computed.
As these are functions, they are approximated by a vector of pivots
denoted by \code{n2_pivots} and \code{c2_pivots}, respectively.
The slots \code{x1_norm_pivots} and \code{weights} are defined
for numerical implementation rules.
The generic implementation of this package is a Gaussian quadrature and
a corresponding design can be built by means of \link{gq_design}.
The user is free to implement own integration rules.
He has to be aware that all elements of \code{x1_norm_pivots} have
to be inside the interval [-1, 1] and have to be scaled by the
applied integration rule.
The parameter \code{tunable} is a logical one and indicates which
design parameters should be tunable for use in optimization.
Rounded sample size values can be applied by the logical parameter
\code{rounded}.

If \code{order} is specified, \code{n2_pivots} and \code{c2_pivots} should
be one-dimensional. They are converted to vectors of length order
automatically.
}
\section{Methods (by generic)}{
\itemize{
\item \code{n}: overall sample size given stage-one outcome

\item \code{scaled_integration_pivots}: get the actual pivots points (knots) of the numerical integration routine
rule.

\item \code{simulate}: simulate from the given design under parameter theta.
}}

\section{Slots}{

\describe{
\item{\code{n1}}{stage-one sample size}

\item{\code{c1f}}{early stopping for futility boundary}

\item{\code{c1e}}{early stopping for efficacy boundary}

\item{\code{n2_pivots}}{vector of length order giving the values of n2 at the
pivot points of the numeric integration rule [TODO: these are not available during construction]}

\item{\code{c2_pivots}}{vector of length order giving the values of c2 at the
pivot points of the numeric integration rule [TODO: these are not available during construction]}

\item{\code{x1_norm_pivots}}{normalized pivots for integration rule (in [-1, 1])}

\item{\code{weights}}{weights of conditional score values at x1_norm_pivots for
approximating the integral over x1.}

\item{\code{tunable}}{named logical vector indicating whether corresponding slot is considered a tunable parameter}
}}

\examples{
order  <- 5L
design <- gq_design(50, 0, 2, rep(50.0, order), rep(2.0, order), order)
cp     <- ConditionalPower(dist = Normal(), prior = PointMassPrior(.4, 1))
plot(design, "Conditional Power" = cp)

}
